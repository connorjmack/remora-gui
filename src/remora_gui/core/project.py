"""Project and SimulationRun models with JSON persistence."""

from __future__ import annotations

import json
import uuid
from dataclasses import asdict, dataclass, field
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Literal

from remora_gui.core.input_file import write_input_file

# ---------------------------------------------------------------------------
# SimulationRun
# ---------------------------------------------------------------------------


@dataclass
class SimulationRun:
    """A single execution of REMORA with a specific configuration."""

    id: str
    project_id: str
    name: str
    created_at: datetime
    status: Literal["draft", "queued", "running", "completed", "failed", "cancelled"] = "draft"

    # Timestamps
    started_at: datetime | None = None
    completed_at: datetime | None = None

    # Configuration
    input_parameters: dict[str, Any] = field(default_factory=dict)
    input_file_path: str = ""
    machine_profile_id: str = ""
    num_procs: int = 1

    # Execution metadata
    pid: int | None = None
    exit_code: int | None = None
    log_path: str | None = None

    # Results
    output_directory: str | None = None
    checkpoint_path: str | None = None
    notes: str = ""
    tags: list[str] = field(default_factory=list)


# ---------------------------------------------------------------------------
# Project
# ---------------------------------------------------------------------------


@dataclass
class Project:
    """A collection of related simulation runs."""

    id: str
    name: str
    description: str
    created_at: datetime
    updated_at: datetime
    base_directory: str
    runs: list[SimulationRun] = field(default_factory=list)

    # ------------------------------------------------------------------
    # Factories
    # ------------------------------------------------------------------

    @staticmethod
    def new(name: str, description: str, base_directory: str | Path) -> Project:
        """Create a new project and its directory structure on disk."""
        base = Path(base_directory)
        base.mkdir(parents=True, exist_ok=True)
        (base / "runs").mkdir(exist_ok=True)
        (base / "templates").mkdir(exist_ok=True)

        now = datetime.now(timezone.utc)
        project = Project(
            id=uuid.uuid4().hex,
            name=name,
            description=description,
            created_at=now,
            updated_at=now,
            base_directory=str(base),
        )
        project.save()
        return project

    # ------------------------------------------------------------------
    # Persistence
    # ------------------------------------------------------------------

    def save(self, path: str | Path | None = None) -> Path:
        """Write project.json to *path* (defaults to base_directory)."""
        dest = Path(path) if path else Path(self.base_directory) / "project.json"
        dest.parent.mkdir(parents=True, exist_ok=True)
        self.updated_at = datetime.now(timezone.utc)
        dest.write_text(json.dumps(asdict(self), default=_json_default, indent=2))
        return dest

    @staticmethod
    def load(path: str | Path) -> Project:
        """Load a Project from a project.json file."""
        p = Path(path)
        if p.is_dir():
            p = p / "project.json"
        data = json.loads(p.read_text())
        return _project_from_dict(data)

    # ------------------------------------------------------------------
    # Run management
    # ------------------------------------------------------------------

    def create_run(
        self,
        name: str,
        params: dict[str, Any],
        machine_profile_id: str = "",
        num_procs: int = 1,
    ) -> SimulationRun:
        """Create a new draft run, write its input file, return it."""
        run_id = uuid.uuid4().hex
        run_dir = Path(self.base_directory) / "runs" / name
        run_dir.mkdir(parents=True, exist_ok=True)

        input_path = run_dir / "inputs"
        write_input_file(
            params,
            input_path,
            header_comment=f"Generated by REMORA-GUI â€” run {name}",
        )

        run = SimulationRun(
            id=run_id,
            project_id=self.id,
            name=name,
            created_at=datetime.now(timezone.utc),
            input_parameters=params,
            input_file_path=str(input_path),
            machine_profile_id=machine_profile_id,
            num_procs=num_procs,
        )
        self.runs.append(run)
        return run


# ---------------------------------------------------------------------------
# JSON helpers
# ---------------------------------------------------------------------------

_ISO_FMT = "%Y-%m-%dT%H:%M:%S.%f%z"


def _json_default(obj: object) -> str:
    """Handle non-serialisable types for ``json.dumps``."""
    if isinstance(obj, datetime):
        return obj.isoformat()
    raise TypeError(f"Object of type {type(obj).__name__} is not JSON serializable")


def _parse_datetime(value: str | None) -> datetime | None:
    if value is None:
        return None
    return datetime.fromisoformat(value)


def _run_from_dict(d: dict[str, Any]) -> SimulationRun:
    return SimulationRun(
        id=d["id"],
        project_id=d["project_id"],
        name=d["name"],
        created_at=_parse_datetime(d["created_at"]),  # type: ignore[arg-type]
        status=d.get("status", "draft"),
        started_at=_parse_datetime(d.get("started_at")),
        completed_at=_parse_datetime(d.get("completed_at")),
        input_parameters=d.get("input_parameters", {}),
        input_file_path=d.get("input_file_path", ""),
        machine_profile_id=d.get("machine_profile_id", ""),
        num_procs=d.get("num_procs", 1),
        pid=d.get("pid"),
        exit_code=d.get("exit_code"),
        log_path=d.get("log_path"),
        output_directory=d.get("output_directory"),
        checkpoint_path=d.get("checkpoint_path"),
        notes=d.get("notes", ""),
        tags=d.get("tags", []),
    )


def _project_from_dict(d: dict[str, Any]) -> Project:
    return Project(
        id=d["id"],
        name=d["name"],
        description=d["description"],
        created_at=_parse_datetime(d["created_at"]),  # type: ignore[arg-type]
        updated_at=_parse_datetime(d["updated_at"]),  # type: ignore[arg-type]
        base_directory=d["base_directory"],
        runs=[_run_from_dict(r) for r in d.get("runs", [])],
    )
